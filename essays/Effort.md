---
layout: essay
type: essay
title: "My Effort in Estimation"
# All dates must be YYYY-MM-DD format!
date: 2025-12-14
published: true
labels:
  - ICS 314
  - Effort Estimation
  - Software Engineering
---
<div class="d-flex align-items-center justify-content-center">
  <img
    width="300px"
    class="rounded me-2"
    src="../img/effort meme.png"
    alt="Bootstrap Framework Image"
  >
  <small class="text-muted">epic embed fail</small>
</div>

## Basis for Effort Estimates
My first effort estimate for the project was made somewhat on a whim. I generally thought about how long it might take to implement the multi-step lifestyle form, including step navigation, question components, validation, and state management. Based on that rough mental estimate, I predicted the task would take around 90 minutes. In reality, this estimate was significantly off.

A major reason for the inaccuracy was unexpected technical issues, particularly complications with my VS Code and GitHub Copilot setup. Troubleshooting and resolving these issues took a considerable amount of time and was not something I had originally accounted for. This experience highlighted how easily estimates can be affected by environmental or tooling problems, even when the core task itself seems straightforward.

For the remainder of the project, I used this first experience as a reference point. I began adjusting my estimates to account not only for the coding itself, but also for potential debugging, configuration issues, and the time required to interact with AI tools such as Copilot. I also intentionally added buffer time to future estimates to better reflect real-world development conditions.

## Value of Estimating in Advance (Even When Inaccurate)
Even though my estimates were often inaccurate, estimating in advance was still beneficial. Having an estimate gave me a rough sense of scope and prevented me from completely underestimating how involved certain tasks might be. It also helped me mentally prepare for the work session by setting expectations around time commitment.

For example, after realizing how much extra time troubleshooting could add, I became more cautious with later estimates. While the exact numbers were not always correct, the act of estimating encouraged me to think critically about task complexity and dependencies ahead of time rather than jumping straight into implementation.

## Usefulness of Tracking Actual Effort
Tracking my actual effort was useful because it provided concrete data to compare against my original estimates. This made it clear where my assumptions were incorrect and helped me understand which parts of development consistently took longer than expected.

As mentioned in the first section, seeing how much time was spent debugging, fixing tooling issues, or refining AI-generated code informed how I approached later estimates. I became more realistic and intentionally padded my estimates to reflect the full development process, not just writing code. This awareness also helped me make better decisions about when to take breaks or stop and continue later.

## Effort Tracking Method and Accuracy
I tracked my actual effort using a very simple method: timing myself with my phone. While this approach was not the most precise, it was easy to use and required no setup, which made it practical during development.

Although this method likely introduced small inaccuracies (such as forgetting to pause the timer or slight delays), I believe it was accurate enough to give a reasonable picture of how long tasks took. For high-level effort tracking and reflection, this approach worked sufficiently well.

## Reflection: Improvements for Next Time
If I were to do this again, I would use a dedicated time-tracking app or website instead of my phone’s timer. A more structured tool would allow me to separate coding time from non-coding activities such as debugging, researching, or prompting AI tools.

Having more detailed breakdowns of how my time is spent would make future estimates more accurate and provide better insight into where inefficiencies occur during development.

## AI Tool Usage
**AI Tools Used**
-  GitHub Copilot (within VS Code)
       Claude Sonnet 4.5
   
**Representative Prompts**
A typical prompt I used was something along the lines of:

  “Can you make me a lifestyle survey? Please make it so that it tracks user progress and allows saving a draft to return to later.”

From there, I would continue asking follow-up prompts for minor changes, fixes, or refinements as I progressed.

**Time Spent**
- Prompt creation: Minimal (usually just a few minutes per prompt)
- Generation: Roughly one-third of the total AI-related time, as GitHub Copilot sometimes took a noticeable amount of time to generate, update, or regenerate its code suggestions.
- Verification and adjustment: The majority of the time, spent reviewing output and making small tweaks

**Acceptance and Edits**
Most of the AI-generated code was accepted as-is. In rare cases, I had to rewrite sections, but more commonly I made small manual adjustments such as changing color values, resizing components, or slightly modifying logic to better fit my needs. Overall, the AI tools significantly accelerated development and reduced the amount of code I needed to write from scratch.


I used chatgpt to help me organize and put my thoughts into a essay format also to help me make it sound more fluid.


